<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Programming Tutorial</title>
    <link rel="stylesheet" href="style1.css">
    <link rel="icon" type="image/x-icon" sizes="32x32"
        href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdhO0Sa8KFwTqE7kclLjyDdNHZTEUw_iKYeA&s">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code&display=swap"
        rel="stylesheet">
        
</head>

<body>
    <header role="banner">
        <h1>C Programming Tutorial</h1>
        <p>Learn C programming step-by-step with examples.</p>
        <button id="theme-toggle" aria-label="Toggle theme">ðŸŒ™ Dark Mode</button>
    </header>

    <button class="sidebar-toggle" aria-label="Toggle sidebar navigation">â˜° Menu</button>
    <nav class="sidebar" role="navigation" aria-label="Main navigation">
        <a href="#intro" data-section="intro"> Introduction</a>
        <a href="#syntax" data-section="syntax"> Program Structure</a>
        <a href="#charset" data-section="charset"> Character Set</a>
        <a href="#variables" data-section="variables"> Variables</a>
       <a href="#datatypes" data-section="datatypes"> Data Types</a> 
       <a href="#constants" data-section="constants"> Constants </a>
       <a href="#operators" data-section="operators"> Operators</a>
       <a href="#boolean" data-section="boolean"> Boolean</a>
      <a href="#switch" data-section="switch"> Switch Statement</a>
    <a href="#whileloop" data-section="whileloop"> While Loop</a>
    <a href="#forloop" data-section="forloop"> For Loop</a>
    <a href="#breakcontinue" data-section="breakcontinue"> Break and Continue</a>
    <a href="#strings" data-section="strings"> Strings</a>
    <a href="#userinput" data-section="userinput"> User Input</a>
    <a href="#memoryaddress" data-section="memoryaddress"> Memory Address</a>
    <a href="#arrays" data-section="arrays"> Arrays</a>
    <a href="#pointers" data-section="pointers"> Pointers</a>

    </nav>

    <main>
        <section id="intro">
            <h2> Introduction to C <span class="progress-check">âœ”</span></h2>
            <p>C is a general-purpose, procedural programming language developed by Dennis Ritchie in 1972 at Bell
                Labs to build the UNIX operating system. Itâ€™s known for its efficiency, low-level memory access, and
                clean syntax,
                making it ideal for system programming, embedded systems,
                and high-performance applications like operating systems, compilers, and game engines.</p><br>
            <h3>Key Features of C :</h3>
            <ul>
                <li>
                    Low-Level Access: Direct memory manipulation via pointers.
                </li>
                <li>
                    Fast and Efficient: Compiles to machine code, offering performance close to assembly language.
                </li>
                <li>
                    portable: Code runs on various platforms with minimal changes.
                </li>
                <li>
                    Structured Programming: Supports functions, loops, conditionals, and modular code.
                </li>
                <li>
                    influential: Many modern languages (C++, Java, Python) derive syntax from C.
                </li>
            </ul><br>


            <h3>Why learn C?</h3>
            <ul>
                <li>Foundational: Builds a deep understanding of programming concepts like variables, data types, and
                    memory management.</li>
                <li>
                    versatile: Used in operating systems (Windows, Linux), embedded systems, and networking.
                </li>
                <li>
                    Career Benefits: High demand for C developers in system programming and embedded systems.
                </li>
                <li>
                    Eases Learning Other Languages: Câ€™s syntax and concepts are a foundation for learning C++, Java, and
                    more.
                </li>

            </ul>

        </section>

        <section id="syntax">
            <h2> C Program Structure <span class="progress-check">âœ”</span></h2>
            <h4>A simple C program looks like this:</h4><br>
            <div class="code-title">Hello World Example</div>
            <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}
// Output: Hello, World!</code></pre><br
            <ul>
              <h5>  <li>#include &lt;stdio.h&gt: Imports input/output functions.</li>
                <li>int main(): Programâ€™s entry point.</li>
                <li>printf: Outputs text to the console.</li>
                <li> return 0: Indicates successful execution</li>
                </h5>
            </ul>
            <br>
            <h3>Installation :</h3>
            <p>If you want to run C program download DEV-C sofware or if you want to run on vs code editor then 
                download minGw compailer and set it up in your vs code editor.
            </p><br>
            <h3>Download links :</h3>
            <p>Download link for DEV C : <a href="https://www.bloodshed.net/"> DEV C++</a>.</p>
            <p>download link for minGw and vs code editor : <a href="https://sourceforge.net/projects/mingw/">minGw</a> and <a href="https://code.visualstudio.com/">Vs Code</a>.</p>
        </section>

        <section id="charset">
    <h2> Character Set <span class="progress-check">âœ”</span></h2>
    <p>The C programming language uses a defined <b>character set</b> to represent source code and data. A character set is the collection of valid characters that C programs can use in identifiers, strings, and character constants. Câ€™s character set is primarily based on the ASCII standard, which has been consistent since Câ€™s creation in 1972 for UNIX development, ensuring portability across systems.</p>
    <p><b>Components of the C Character Set:</b></p>
    <ul>
        <li><b>Letters:</b> Uppercase (A-Z) and lowercase (a-z) for identifiers (e.g., variable names).</li>
        <li><b>Digits:</b> 0-9 for numeric constants.</li>
        <li><b>Special Characters:</b> Symbols like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&</code>, <code>|</code>, <code>!</code>, etc., for operators and punctuation.</li>
        <li><b>White Spaces:</b> Spaces, tabs (\t), newlines (\n), and carriage returns (\r) for formatting.</li>
        <li><b>Escape Sequences:</b> Special characters like <code>\n</code> (newline), <code>\t</code> (tab), <code>\'</code> (single quote), and <code>\"</code> (double quote) for use in strings and character literals.</li>
    </ul>
    <p><b>Note:</b> C uses the <code>char</code> data type to store characters, typically as 1-byte ASCII values (0 to 127 for signed, 0 to 255 for unsigned). Since the C99 standard, C also supports extended character sets like Unicode via wide characters (<code>wchar_t</code>).</p>
    <div class="code-title">Character Set Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    char letter = 'A';
    char digit = '5';
    char symbol = '#';
    char newline = '\n';
    
    printf("Letter: %c\n", letter);
    printf("Digit: %c\n", digit);
    printf("Symbol: %c\n", symbol);
    printf("Escape Sequence (newline): %cHello after newline\n", newline);
    printf("ASCII value of 'A': %d\n", letter);

    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>Letter: A
Digit: 5
Symbol: #
Escape Sequence (newline): 
Hello after newline
ASCII value of 'A': 65
</code></pre>
    <p><b>Historical Note:</b> Câ€™s character set, rooted in ASCII, was chosen in the 1970s for simplicity and compatibility with early UNIX systems. The C89 standard formalized ASCII as the default, while C99 introduced support for extended character sets to accommodate internationalization, reflecting Câ€™s evolution to modern needs by 2025.</p>
</section>
<section id="variables">
    <h2> Variables <span class="progress-check">âœ”</span></h2>
    <p>In C, a <b>variable</b> is a named storage location in memory used to hold data that can be modified during program execution. Variables must be declared with a specific data type before use, reflecting Câ€™s structured and type-safe design, established in 1972 by Dennis Ritchie for UNIX development. Variables are fundamental to manipulating data, such as numbers, characters, or user input.</p>
    <p><b>Key Rules for Variables:</b></p>
    <ul>
        <li><b>Declaration:</b> Specify the data type and name (e.g., <code>int age;</code>).</li>
        <li><b>Initialization:</b> Assign a value at declaration (e.g., <code>int age = 20;</code>) or later.</li>
        <li><b>Naming:</b> Use letters, digits, or underscores; start with a letter or underscore; case-sensitive (e.g., <code>Age</code> â‰  <code>age</code>).</li>
        <li><b>Scope:</b> Variables have local (within a function/block) or global (outside functions) scope.</li>
        <li><b>Storage Classes:</b> Modifiers like <code>auto</code>, <code>register</code>, <code>static</code>, or <code>extern</code> control lifetime and visibility.</li>
    </ul>
    <p><b>Note:</b> Câ€™s variable declaration syntax, formalized in the C89 standard, ensures type safety and efficient memory use. Variable sizes depend on data types (e.g., <code>int</code> is typically 4 bytes on 64-bit systems).</p> <br>
    <div class="code-title">Variables Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int global_var = 100; // Global variable

int main() {
    int age = 20;        // Local variable
    float salary = 2500.50;
    char grade = 'B';
    static int counter = 0; // Static variable retains value between calls

    counter++;
    printf("Global variable: %d\n", global_var);
    printf("Local variable (age): %d\n", age);
    printf("Local variable (salary): %.2f\n", salary);
    printf("Local variable (grade): %c\n", grade);
    printf("Static variable (counter): %d\n", counter);

    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>Global variable: 100
Local variable (age): 20
Local variable (salary): 2500.50
Local variable (grade): B
Static variable (counter): 1
</code></pre> <br>
    <p><b>Historical Note:</b> Câ€™s variable system, introduced in the 1970s, allowed fine-grained control over memory, key for UNIXâ€™s portability. The C89 standard formalized declarations, while C99 added features like variable-length arrays, enhancing flexibility for modern applications in 2025.</p>
</section>


        <section id="datatypes">
    <h2> Data Types in C <span class="progress-check">âœ”</span></h2>
    <p>C provides a set of basic data types for storing different kinds of values. These types are fundamental to Câ€™s efficiency and low-level control, designed to work closely with hardware. Below are the core data types, their typical sizes (on a 64-bit system), and their uses:</p>
    <ul>
        <li><b>int:</b> Stores whole numbers (e.g., 20). Typically 4 bytes, with a range of -2,147,483,648 to 2,147,483,647 (signed).</li>
        <li><b>float:</b> Stores single-precision decimal numbers (e.g., 3.14). 4 bytes, with ~6-7 digits of precision.</li>
        <li><b>double:</b> Stores double-precision decimal numbers (e.g., 3.14159265359). 8 bytes, with ~15-16 digits of precision.</li>
        <li><b>char:</b> Stores single characters (e.g., 'A') or small integers. 1 byte, with a range of -128 to 127 (signed) or 0 to 255 (unsigned).</li>
        <li><b>_Bool:</b> Stores Boolean values (0 for false, non-zero for true). Introduced in C99, typically 1 byte.</li>
    </ul>
    <p><b>Modifiers:</b> Use <code>signed</code>, <code>unsigned</code>, <code>short</code>, or <code>long</code> to adjust range or size (e.g., <code>unsigned int</code>, <code>long long int</code>). Note that sizes may vary by platform (e.g., 32-bit vs. 64-bit systems), a consideration since Câ€™s early days in the 1970s.</p> <br>    <div class="code-title">Data Types Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int age = 20;
    float pi = 3.14;
    double large_pi = 3.14159265359;
    char grade = 'A';
    _Bool is_valid = 1;

    printf("Integer (int): %d, Size: %zu bytes\n", age, sizeof(age));
    printf("Float: %.2f, Size: %zu bytes\n", pi, sizeof(pi));
    printf("Double: %.10f, Size: %zu bytes\n", large_pi, sizeof(large_pi));
    printf("Character (char): %c, Size: %zu bytes\n", grade, sizeof(grade));
    printf("Boolean (_Bool): %d, Size: %zu bytes\n", is_valid, sizeof(is_valid));

    return 0;
}
</code></pre>
    <p><b>Output (on a 64-bit system):</b></p>
    <pre><code>Integer (int): 20, Size: 4 bytes
Float: 3.14, Size: 4 bytes
Double: 3.1415926536, Size: 8 bytes
Character (char): A, Size: 1 byte
Boolean (_Bool): 1, Size: 1 byte
</code></pre> <br>
    <p><b>Note:</b> Câ€™s data types, formalized in the C89 standard, are designed for portability and performance. The <code>sizeof</code> operator reveals type sizes, which may differ across systems, reflecting Câ€™s hardware-dependent roots from its creation in 1972 for UNIX development.</p>
</section>



<section id="constants">
    <h2> Constants <span class="progress-check">âœ”</span></h2>
    <p>In C, a <b>constant</b> is a value that cannot be modified during program execution. Constants are used to define fixed values, such as mathematical constants or configuration settings, ensuring code reliability and readability. Introduced in Câ€™s design in 1972 by Dennis Ritchie for UNIX, constants leverage Câ€™s type system to provide immutable data, formalized in the C89 standard.</p>
    <p><b>Types of Constants:</b></p>
    <ul>
        <li><b>Literal Constants:</b> Fixed values like integers (e.g., <code>42</code>), floating-point numbers (e.g., <code>3.14</code>), characters (e.g., <code>'A'</code>), or strings (e.g., <code>"Hello"</code>).</li>
        <li><b>Const Keyword:</b> Variables declared with <code>const</code> cannot be modified (e.g., <code>const int MAX = 100;</code>).</li>
        <li><b>#define Preprocessor:</b> Defines symbolic constants via macros (e.g., <code>#define PI 3.14</code>).</li>
        <li><b>Enumeration Constants:</b> Named integer constants using <code>enum</code> (e.g., <code>enum { RED = 1, GREEN, BLUE };</code>).</li>
    </ul>
    <p><b>Note:</b> Constants enhance code clarity and prevent accidental changes. The <code>const</code> keyword, introduced in C89, ensures type safety, while <code>#define</code> is a legacy approach from Câ€™s early days. Use <code>const</code> for type-checked constants in modern C (2025).</p>
    <br><div class="code-title">Constants Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

#define PI 3.14159 // Preprocessor constant

int main() {
    const int MAX_AGE = 150; // Const variable
    enum colors { RED = 1, GREEN, BLUE }; // Enumeration constants
    
    printf("Literal Integer: %d\n", 42);
    printf("Literal Float: %.2f\n", 2.718);
    printf("Literal Character: %c\n", 'X');
    printf("Literal String: %s\n", "Hello, C!");
    printf("Const Variable (MAX_AGE): %d\n", MAX_AGE);
    printf("Preprocessor Constant (PI): %.5f\n", PI);
    printf("Enum Constant (GREEN): %d\n", GREEN);
    
    // MAX_AGE = 200; // Error: cannot modify const
    // PI = 3.14; // Error: PI is a preprocessor constant
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>Literal Integer: 42
Literal Float: 2.72
Literal Character: X
Literal String: Hello, C!
Const Variable (MAX_AGE): 150
Preprocessor Constant (PI): 3.14159
Enum Constant (GREEN): 2
</code></pre>
    <br><p><b>Historical Note:</b> Constants in C, rooted in its 1972 design, provided fixed values for UNIX system programming. The C89 standard introduced <code>const</code> for type-safe immutability, while C99 and later standards enhanced enumeration support, ensuring constants remain vital for reliable code in 2025.</p>
</section>

<section id="operators">
    <h2> Operators <span class="progress-check">âœ”</span></h2>
    <p>In C, <b>operators</b> are symbols that perform operations on variables and values, such as arithmetic calculations, comparisons, or logical operations. Operators are a core part of Câ€™s syntax, designed in 1972 by Dennis Ritchie to enable efficient manipulation of data in UNIX system programming. They work with Câ€™s data types and variables, providing flexibility and control.</p>
    <p><b>Types of Operators:</b></p>
    <ul>
        <li><b>Arithmetic Operators:</b> Perform mathematical operations (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>).</li>
        <li><b>Relational Operators:</b> Compare values (e.g., <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>).</li>
        <li><b>Logical Operators:</b> Combine conditions (e.g., <code>&&</code>, <code>||</code>, <code>!</code>).</li>
        <li><b>Bitwise Operators:</b> Manipulate bits (e.g., <code>&</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>).</li>
        <li><b>Assignment Operators:</b> Assign values (e.g., <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>).</li>
        <li><b>Miscellaneous Operators:</b> Include <code>sizeof</code>, <code>&</code> (address), <code>*</code> (dereference), and <code>?:</code> (ternary).</li>
    </ul>
    <p><b>Note:</b> Operators follow a precedence order, with parentheses <code>()</code> used to override it. The C89 standard formalized operator behavior, ensuring portability across platforms, a key feature for Câ€™s use in 2025.</p>
    <div class="code-title">Operators Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 3;
    int sum = a + b;            // Arithmetic
    int mod = a % b;            // Arithmetic
    int is_equal = (a == b);    // Relational
    int logical = (a > 0 && b > 0); // Logical
    int bitwise = a & b;        // Bitwise
    a += 5;                     // Assignment
    
    printf("Arithmetic (+): %d\n", sum);
    printf("Arithmetic (%%): %d\n", mod);
    printf("Relational (==): %d\n", is_equal);
    printf("Logical (&&): %d\n", logical);
    printf("Bitwise (&): %d\n", bitwise);
    printf("Assignment (+=): %d\n", a);
    printf("Ternary (?:): %s\n", (a > b) ? "a is greater" : "b is greater");
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>Arithmetic (+): 13
Arithmetic (%): 1
Relational (==): 0
Logical (&&): 1
Bitwise (&): 2
Assignment (+=): 15
Ternary (?:): a is greater
</code></pre>
    <p><b>Historical Note:</b> Câ€™s operators, rooted in its 1972 design, enabled efficient computation for UNIX. The C89 standard standardized operator precedence and behavior, while C99 introduced features like compound literals, enhancing operator use in modern applications by 2025.</p>
</section>

<section id="boolean">
    <h2> Boolean <span class="progress-check">âœ”</span></h2>
    <p>In C, the <b>Boolean</b> type, represented by <code>_Bool</code>, is used to store true or false values, primarily for logical operations and conditions. Introduced in the C99 standard, <code>_Bool</code> is a fundamental data type that holds <code>0</code> (false) or any non-zero value (true). Before C99, C used integers (<code>0</code> for false, non-zero for true) for Boolean logic, reflecting its minimalist design from 1972 by Dennis Ritchie for UNIX.</p>
    <p><b>Key Points about Boolean:</b></p>
    <ul>
        <li><b>Type:</b> <code>_Bool</code>, typically 1 byte, stores <code>0</code> (false) or <code>1</code> (true).</li>
        <li><b>Header:</b> Include <code>&lt;stdbool.h&gt;</code> for <code>bool</code>, <code>true</code>, and <code>false</code> macros for readability.</li>
        <li><b>Usage:</b> Used with relational (<code>==</code>, <code>&gt;</code>) and logical operators (<code>&&</code>, <code>||</code>, <code>!</code>).</li>
        <li><b>Conversion:</b> Assigning any non-zero value to <code>_Bool</code> sets it to <code>1</code>; zero sets it to <code>0</code>.</li>
    </ul>
    <p><b>Note:</b> Before C99, programmers used <code>int</code> for Boolean logic, a common practice in early UNIX programming. In modern C (2025), use <code>bool</code> with <code>&lt;stdbool.h&gt;</code> for clarity and portability.</p>
    <div class="code-title">Boolean Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main() {
    _Bool is_active = 1;        // Native _Bool
    bool is_valid = true;       // Using stdbool.h
    int value = 42;
    bool is_positive = value > 0; // Relational operator
    bool logical_and = (value > 0 && is_valid); // Logical operator
    
    printf("Native _Bool (is_active): %d\n", is_active);
    printf("bool (is_valid): %d\n", is_valid);
    printf("Relational (is_positive): %d\n", is_positive);
    printf("Logical AND (logical_and): %d\n", logical_and);
    printf("Size of _Bool: %zu bytes\n", sizeof(_Bool));
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>Native _Bool (is_active): 1
bool (is_valid): 1
Relational (is_positive): 1
Logical AND (logical_and): 1
Size of _Bool: 1
</code></pre>
    <p><b>Historical Note:</b> Câ€™s lack of a Boolean type until C99 reflected its 1972 design for simplicity and efficiency in UNIX. The C99 standard introduced <code>_Bool</code> and <code>&lt;stdbool.h&gt;</code> to align with modern programming needs, ensuring compatibility and clarity in 2025 applications.</p>
</section>

<section id="switch">
    <h2> Switch Statement <span class="progress-check">âœ”</span></h2>
    <p>The <b>switch</b> statement in C provides a way to execute one of many code blocks based on the value of an expression, offering an alternative to multiple <code>if-else</code> statements. Introduced in Câ€™s 1972 design for structured control flow in UNIX, itâ€™s efficient for multi-way branching.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Syntax:</b> Uses <code>switch(expression)</code> with <code>case</code> labels and an optional <code>default</code>.</li>
        <li><b>Break:</b> <code>break</code> exits the switch to prevent fall-through to subsequent cases.</li>
        <li><b>Expression:</b> Typically an integer or <code>char</code>, evaluated once.</li>
    </ul>
    <p><b>Note:</b> The C89 standard formalized switch behavior, ensuring portability. Use <code>break</code> to avoid unintended fall-through, a common pitfall in early C programs.</p>
    <div class="code-title">Switch Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int day = 3;
    
    switch (day) {
        case 1:
            printf("Monday\n");
            break;
        case 2:
            printf("Tuesday\n");
            break;
        case 3:
            printf("Wednesday\n");
            break;
        default:
            printf("Invalid day\n");
    }
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>Wednesday
</code></pre>
    <p><b>Historical Note:</b> The switch statement, part of Câ€™s 1972 design, optimized control flow for UNIX utilities. C89 standardized its semantics, making it a staple for multi-way decisions in 2025.</p>
</section>

<section id="whileloop">
    <h2> While Loop <span class="progress-check">âœ”</span></h2>
    <p>The <b>while</b> loop in C repeatedly executes a block of code as long as a condition is true, ideal for indefinite iteration. Designed in 1972 for UNIX, it provides flexible looping with minimal syntax.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Syntax:</b> <code>while (condition) { statements; }</code>.</li>
        <li><b>Condition:</b> Evaluated before each iteration; must be false to exit.</li>
        <li><b>Infinite Loop:</b> Occurs if the condition never becomes false (e.g., <code>while (1)</code>).</li>
    </ul>
    <p><b>Note:</b> The C89 standard ensured consistent loop behavior. Always ensure the condition can become false to avoid infinite loops.</p>
    <div class="code-title">While Loop Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int i = 1;
    
    while (i <= 5) {
        printf("%d ", i);
        i++;
    }
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>1 2 3 4 5
</code></pre>
    <p><b>Historical Note:</b> Câ€™s while loop, from 1972, enabled efficient iteration in UNIX. C99â€™s Boolean enhancements improved condition clarity, maintaining relevance in 2025.</p>
</section>

<section id="forloop">
    <h2> For Loop <span class="progress-check">âœ”</span></h2>
    <p>The <b>for</b> loop in C is used for definite iteration, executing a block of code a specific number of times. Introduced in 1972, itâ€™s compact and widely used for counted loops in C programs.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Syntax:</b> <code>for (init; condition; update) { statements; }</code>.</li>
        <li><b>Components:</b> Initialization, condition check, and update expression.</li>
        <li><b>Flexibility:</b> Any component can be omitted, but semicolons are required.</li>
    </ul>
    <p><b>Note:</b> Standardized in C89, the for loop is ideal for array iteration and precise control, common in modern C applications.</p>
    <div class="code-title">For Loop Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    for (int i = 1; i <= 5; i++) {
        printf("%d ", i);
    }
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>1 2 3 4 5
</code></pre>
    <p><b>Historical Note:</b> The for loop, part of Câ€™s 1972 design, streamlined iteration for UNIX. C99 allowed declarations in the init clause (e.g., <code>for (int i = 0; ...)</code>), enhancing its usability.</p>
</section>

<section id="breakcontinue">
    <h2> Break and Continue <span class="progress-check">âœ”</span></h2>
    <p>The <b>break</b> and <b>continue</b> statements in C control loop and switch execution. <code>break</code> exits a loop or switch, while <code>continue</code> skips to the next loop iteration. Introduced in 1972, they provide precise flow control.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Break:</b> Terminates the nearest enclosing loop or switch.</li>
        <li><b>Continue:</b> Skips the current iteration and proceeds to the next.</li>
        <li><b>Usage:</b> Common in loops and switch statements for conditional control.</li>
    </ul>
    <p><b>Note:</b> C89 standardized their behavior, ensuring consistent use in loops and switches.</p>
    <div class="code-title">Break and Continue Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    for (int i = 1; i <= 5; i++) {
        if (i == 3) continue; // Skip 3
        if (i == 5) break;   // Exit at 5
        printf("%d ", i);
    }
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>1 2 4
</code></pre>
    <p><b>Historical Note:</b> Break and continue, from Câ€™s 1972 design, enabled fine-grained control in UNIX. Their standardized behavior in C89 ensures reliability in 2025.</p>
</section>

<section id="strings">
    <h2> Strings <span class="progress-check">âœ”</span></h2>
    <p>In C, a <b>string</b> is an array of characters terminated by a null character (<code>\0</code>). Strings are used to store text and are manipulated using standard library functions from <code>&lt;string.h&gt;</code>. Introduced in 1972, strings are central to Câ€™s text processing.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Declaration:</b> As <code>char</code> arrays (e.g., <code>char str[] = "Hello";</code>).</li>
        <li><b>Null Termination:</b> Ends with <code>\0</code> to mark the stringâ€™s end.</li>
        <li><b>Library Functions:</b> <code>strlen</code>, <code>strcpy</code>, <code>strcmp</code>, etc.</li>
    </ul>
    <p><b>Note:</b> C89 standardized string handling, with C99 adding support for wide characters. Strings require careful memory management to avoid overflows.</p>
    <div class="code-title">Strings Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[] = "Hello, C!";
    
    printf("String: %s\n", str);
    printf("Length: %zu\n", strlen(str));
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>String: Hello, C!
Length: 9
</code></pre>
    <p><b>Historical Note:</b> Strings, part of Câ€™s 1972 design, enabled text processing in UNIX. C99â€™s wide character support expanded their use for internationalization in 2025.</p>
</section>

<section id="userinput">
    <h2> User Input <span class="progress-check">âœ”</span></h2>
    <p>C supports <b>user input</b> through standard library functions like <code>scanf</code> and <code>getchar</code> from <code>&lt;stdio.h&gt;</code>, allowing programs to read data from the user. Introduced in 1972, input functions were key for interactive UNIX programs.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>scanf:</b> Reads formatted input (e.g., <code>scanf("%d", &x);</code>).</li>
        <li><b>getchar:</b> Reads a single character.</li>
        <li><b>Buffer Safety:</b> Use caution to avoid buffer overflows with strings.</li>
    </ul>
    <p><b>Note:</b> C89 standardized input functions, but modern C requires careful handling to prevent security issues.</p>
    <div class="code-title">User Input Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int age;
    char name[20];
    
    printf("Enter your age: ");
    scanf("%d", &age);
    printf("Enter your name: ");
    scanf("%s", name);
    
    printf("Age: %d, Name: %s\n", age, name);
    
    return 0;
}
</code></pre>
    <p><b>Output (example input):</b></p>
    <pre><code>Enter your age: 25
Enter your name: Alice
Age: 25, Name: Alice
</code></pre>
    <p><b>Historical Note:</b> User input, from Câ€™s 1972 design, enabled interactive UNIX tools. C89â€™s standardization of <code>scanf</code> ensures portability, though modern C emphasizes safe input handling.</p>
</section>

<section id="memoryaddress">
    <h2> Memory Address <span class="progress-check">âœ”</span></h2>
    <p>In C, a <b>memory address</b> is the location in memory where a variable is stored, accessible via the address-of operator (<code>&</code>). Câ€™s low-level memory access, designed in 1972 for UNIX, makes addresses critical for pointers and dynamic memory.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Address Operator:</b> <code>&variable</code> returns the memory address.</li>
        <li><b>Format:</b> Printed as hexadecimal using <code>%p</code> in <code>printf</code>.</li>
        <li><b>Use:</b> Essential for pointers and memory management.</li>
    </ul>
    <p><b>Note:</b> C89 standardized address operations, ensuring consistent memory handling across platforms.</p>
    <div class="code-title">Memory Address Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int x = 42;
    
    printf("Value of x: %d\n", x);
    printf("Address of x: %p\n", (void*)&x);
    
    return 0;
}
</code></pre>
    <p><b>Output (example address):</b></p>
    <pre><code>Value of x: 42
Address of x: 0x7ffee4c4a4ac
</code></pre>
    <p><b>Historical Note:</b> Memory addresses, central to Câ€™s 1972 design, enabled low-level control for UNIX. C89â€™s standardization ensured portability, vital for 2025 system programming.</p>
</section>

<section id="arrays">
    <h2> Arrays <span class="progress-check">âœ”</span></h2>
    <p>An <b>array</b> in C is( Linear Data Structure) a collection of elements of the same data type, stored contiguously in memory. Introduced in 1972, arrays are fundamental for handling multiple values efficiently in C programs.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Declaration:</b> <code>type name[size];</code> (e.g., <code>int arr[5];</code>).</li>
        <li><b>Indexing:</b> Zero-based (e.g., <code>arr[0]</code> to <code>arr[4]</code>).</li>
        <li><b>Memory:</b> Contiguous allocation, accessible via pointers.</li>
    </ul>
    <p><b>Note:</b> C99 introduced variable-length arrays (VLAs), but fixed-size arrays remain common. Always check bounds to avoid errors.</p>
    <div class="code-title">Arrays Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    return 0;
}
</code></pre>
    <p><b>Output:</b></p>
    <pre><code>arr[0] = 10
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 50
</code></pre>
    <p><b>Historical Note:</b> Arrays, from Câ€™s 1972 design, enabled efficient data storage in UNIX. C99â€™s VLAs added flexibility, maintaining arraysâ€™ importance in 2025.</p>
</section>

<section id="pointers">
    <h2> Pointers <span class="progress-check">âœ”</span></h2>
    <p>A <b>pointer</b> in C is a variable that stores a memory address, enabling direct memory manipulation. Central to Câ€™s 1972 design for UNIX, pointers are key for dynamic memory and efficient data handling.</p>
    <p><b>Key Points:</b></p>
    <ul>
        <li><b>Declaration:</b> <code>type *name;</code> (e.g., <code>int *ptr;</code>).</li>
        <li><b>Operators:</b> <code>&</code> (address), <code>*</code> (dereference).</li>
        <li><b>Use:</b> For arrays, dynamic memory, and function arguments.</li>
    </ul>
    <p><b>Note:</b> C89 standardized pointer behavior. Pointers require careful use to avoid errors like null pointer dereferencing.</p>
    <div class="code-title">Pointers Example</div>
    <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int x = 42;
    int *ptr = &x;
    
    printf("Value of x: %d\n", x);
    printf("Address of x: %p\n", (void*)&x);
    printf("Value via pointer: %d\n", *ptr);
    
    return 0;
}
</code></pre>
    <p><b>Output (example address):</b></p>
    <pre><code>Value of x: 42
Address of x: 0x7ffee4c4a4ac
Value via pointer: 42
</code></pre>
    <p><b>Historical Note:</b> Pointers, a hallmark of Câ€™s 1972 design, enabled low-level memory control for UNIX. C89â€™s standardization ensures their reliability in 2025 applications.</p>
</section>
      
    </main>

    <footer>
        <p>Â© 2025 C Programming Tutorial | Designed for Learning</p>
    </footer>

    <script src="script.js"></script>
</body>

</html>