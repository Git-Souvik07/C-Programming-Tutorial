<a href="#strings" data-section="strings">Strings</a>
            <a href="#memoryaddress" data-section="memoryaddress">Memory Address</a>
            <a href="#arrays" data-section="arrays">Arrays</a>
            <a href="#pointers" data-section="pointers">Pointers</a>

             <section id="strings">
            <h2> Strings <span class="progress-check">✔</span></h2>
            <p>In C, a <b>string</b> is an array of characters terminated by a null character (<code>\0</code>). Strings
                are used to store text and are manipulated using standard library functions from
                <code>&lt;string.h&gt;</code>. Introduced in 1972, strings are central to C’s text processing.</p>
            <p><b>Key Points:</b></p>
            <ul>
                <li><b>Declaration:</b> As <code>char</code> arrays (e.g., <code>char str[] = "Hello";</code>).</li>
                <li><b>Null Termination:</b> Ends with <code>\0</code> to mark the string’s end.</li>
                <li><b>Library Functions:</b> <code>strlen</code>, <code>strcpy</code>, <code>strcmp</code>, etc.</li>
            </ul>
            <p><b>Note:</b> C89 standardized string handling, with C99 adding support for wide characters. Strings
                require careful memory management to avoid overflows.</p>
            <div class="code-title">Strings Example</div>
            <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[] = "Hello, C!";
    
    printf("String: %s\n", str);
    printf("Length: %zu\n", strlen(str));
    
    return 0;
}
</code></pre>
            <p><b>Output:</b></p>
            <pre><code>String: Hello, C!
Length: 9
</code></pre>
            <p><b>Historical Note:</b> Strings, part of C’s 1972 design, enabled text processing in UNIX. C99’s wide
                character support expanded their use for internationalization in 2025.</p>
        </section>

        

        <section id="memoryaddress">
            <h2> Memory Address <span class="progress-check">✔</span></h2>
            <p>In C, a <b>memory address</b> is the location in memory where a variable is stored, accessible via the
                address-of operator (<code>&</code>). C’s low-level memory access, designed in 1972 for UNIX, makes
                addresses critical for pointers and dynamic memory.</p>
            <p><b>Key Points:</b></p>
            <ul>
                <li><b>Address Operator:</b> <code>&variable</code> returns the memory address.</li>
                <li><b>Format:</b> Printed as hexadecimal using <code>%p</code> in <code>printf</code>.</li>
                <li><b>Use:</b> Essential for pointers and memory management.</li>
            </ul>
            <p><b>Note:</b> C89 standardized address operations, ensuring consistent memory handling across platforms.
            </p>
            <div class="code-title">Memory Address Example</div>
            <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int x = 42;
    
    printf("Value of x: %d\n", x);
    printf("Address of x: %p\n", (void*)&x);
    
    return 0;
}
</code></pre>
            <p><b>Output (example address):</b></p>
            <pre><code>Value of x: 42
Address of x: 0x7ffee4c4a4ac
</code></pre>
            <p><b>Historical Note:</b> Memory addresses, central to C’s 1972 design, enabled low-level control for UNIX.
                C89’s standardization ensured portability, vital for 2025 system programming.</p>
        </section>

        <section id="arrays">
            <h2> Arrays <span class="progress-check">✔</span></h2>
            <p>An <b>array</b> in C is( Linear Data Structure) a collection of elements of the same data type, stored
                contiguously in memory. Introduced in 1972, arrays are fundamental for handling multiple values
                efficiently in C programs.</p>
            <p><b>Key Points:</b></p>
            <ul>
                <li><b>Declaration:</b> <code>type name[size];</code> (e.g., <code>int arr[5];</code>).</li>
                <li><b>Indexing:</b> Zero-based (e.g., <code>arr[0]</code> to <code>arr[4]</code>).</li>
                <li><b>Memory:</b> Contiguous allocation, accessible via pointers.</li>
            </ul>
            <p><b>Note:</b> C99 introduced variable-length arrays (VLAs), but fixed-size arrays remain common. Always
                check bounds to avoid errors.</p>
            <div class="code-title">Arrays Example</div>
            <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    return 0;
}
</code></pre>
            <p><b>Output:</b></p>
            <pre><code>arr[0] = 10
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 50
</code></pre>
            <p><b>Historical Note:</b> Arrays, from C’s 1972 design, enabled efficient data storage in UNIX. C99’s VLAs
                added flexibility, maintaining arrays’ importance in 2025.</p>
        </section>

        <section id="pointers">
            <h2> Pointers <span class="progress-check">✔</span></h2>
            <p>A <b>pointer</b> in C is a variable that stores a memory address, enabling direct memory manipulation.
                Central to C’s 1972 design for UNIX, pointers are key for dynamic memory and efficient data handling.
            </p>
            <p><b>Key Points:</b></p>
            <ul>
                <li><b>Declaration:</b> <code>type *name;</code> (e.g., <code>int *ptr;</code>).</li>
                <li><b>Operators:</b> <code>&</code> (address), <code>*</code> (dereference).</li>
                <li><b>Use:</b> For arrays, dynamic memory, and function arguments.</li>
            </ul>
            <p><b>Note:</b> C89 standardized pointer behavior. Pointers require careful use to avoid errors like null
                pointer dereferencing.</p>
            <div class="code-title">Pointers Example</div>
            <pre data-lang="C"><button class="copy-btn">Copy</button><code>#include &lt;stdio.h&gt;

int main() {
    int x = 42;
    int *ptr = &x;
    
    printf("Value of x: %d\n", x);
    printf("Address of x: %p\n", (void*)&x);
    printf("Value via pointer: %d\n", *ptr);
    
    return 0;
}
</code></pre>
            <p><b>Output (example address):</b></p>
            <pre><code>Value of x: 42
Address of x: 0x7ffee4c4a4ac
Value via pointer: 42
</code></pre>
            <p><b>Historical Note:</b> Pointers, a hallmark of C’s 1972 design, enabled low-level memory control for
                UNIX. C89’s standardization ensures their reliability in 2025 applications.</p>
        </section>